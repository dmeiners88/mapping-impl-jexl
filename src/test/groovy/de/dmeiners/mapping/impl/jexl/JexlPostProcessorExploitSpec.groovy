package de.dmeiners.mapping.impl.jexl

import de.dmeiners.mapping.api.ExecutionException
import de.dmeiners.mapping.api.ResultTypeException
import org.junit.Rule
import org.junit.contrib.java.lang.system.ExpectedSystemExit
import org.junit.contrib.java.lang.system.ProvideSecurityManager
import spock.lang.Specification

import java.security.AccessControlException

class JexlPostProcessorExploitSpec extends Specification {


    def "a script cannot exit the JVM via System.exit()"() {

        given:
        def scriptText = "i = ${input};" +
                "clazz = i.class;" +
                "system = clazz.forName('java.lang.System');" +
                "methods = system.getMethods();" +
                "for(method : methods) { if (method.getName().equals('exit')) { method.invoke(null, 111); } }"
        def target = "Unchanged"
        def subject = new JexlPostProcessor()

        when:
        def script = subject.compileInline(scriptText)
        script.execute(target, [:])

        then:
        thrown(ExecutionException)

        where:
        input << [
                1 as Byte,
                1 as Short,
                1 as Integer,
                1 as Long,
                1 as Float,
                1 as Double,
                true as Boolean,
                "a" as Character
        ]
    }

    def "a script cannot exit the JVM via Runtime.exit()"() {

        given:
        def scriptText = "i = ${input};" +
                "clazz = i.class;" +
                "runtime = clazz.forName('java.lang.Runtime');" +
                "methods = runtime.getMethods();" +
                "for(method : methods) { if (method.getName().equals('getRuntime')) { method.invoke(null).exit(111); } }"
        def target = "Unchanged"
        def subject = new JexlPostProcessor()

        when:
        def script = subject.compileInline(scriptText)
        script.execute(target, [:])

        then:
        thrown(ExecutionException)

        where:
        input << [
                1 as Byte,
                1 as Short,
                1 as Integer,
                1 as Long,
                1 as Float,
                1 as Double,
                true as Boolean,
                "a" as Character
        ]
    }

    def "a script cannot exit the JVM via System.exit() easily"() {

        given:
        def scriptText = "target.exit(111);"
        def target = System
        def subject = new JexlPostProcessor()

        when:
        def script = subject.compileInline(scriptText)
        script.execute(target, [:])

        then:
        thrown(ExecutionException)
    }

    def "a script cannot exit the JVM via Runtime.exit() easily"() {

        given:
        def scriptText = "target.exit(111);"
        def target = Runtime.getRuntime()
        def subject = new JexlPostProcessor()

        when:
        def script = subject.compileInline(scriptText)
        script.execute(target, [:])

        then:
        thrown(ExecutionException)
    }

    def "a script cannot return a type different from the input type"() {

        given:
        def scriptText = "return target.length()"
        def target = "Hello World!"
        def subject = new JexlPostProcessor()

        when:
        def script = subject.compileInline(scriptText)
        script.execute(target, [:])

        then:
        def e = thrown(ResultTypeException)
        e.message == "Script did not return an object of type 'java.lang.String'."
    }

    def "a script cannot list local filesystem contents"() {

        given:
        def scriptText = """
decimal = new('java.math.BigDecimal', 10);
clazz = decimal.class;
files = clazz.forName('java.nio.file.Files');
paths = clazz.forName('java.nio.file.Paths');
entries = files.list(paths.get('C:\\\\'));
iterator = entries.iterator();
for (entry : iterator) {
    target += '; ' + entry.toString();
}
"""
        def target = ""
        def subject = new JexlPostProcessor()

        when:
        def script = subject.compileInline(scriptText)
        def result = script.execute(target, [:])
        println result

        then:
        thrown(AccessControlException)
    }
}
